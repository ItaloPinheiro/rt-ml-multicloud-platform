name: Continuous Deployment

on:
  push:
    branches: [ main ]
    tags: [ 'v*' ]
  workflow_dispatch:
    inputs:
      deploy_staging:
        description: 'Deploy to staging cluster'
        required: false
        type: boolean
        default: false
      deploy_production:
        description: 'Deploy to production cluster'
        required: false
        type: boolean
        default: false

env:
  REGISTRY: ghcr.io
  PYTHON_VERSION: '3.13'
  
  # ============================================================================
  # DEPLOYMENT FEATURE FLAGS
  # Set to 'true' when infrastructure is ready
  # ============================================================================
  ENABLE_STAGING_DEPLOY: 'false'      # Set to 'true' when staging K8s is ready
  ENABLE_PRODUCTION_DEPLOY: 'false'   # Set to 'true' when production K8s is ready
  ENABLE_SLACK_NOTIFICATIONS: 'false' # Set to 'true' when Slack webhook is configured

jobs:


  # ==========================================================================
  # BUILD AND PUSH - Always runs
  # ==========================================================================
  build-and-push:
    name: Build & Push Docker Images
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-tag: ${{ steps.meta.outputs.tags }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Image Name (Lowercase)
      run: |
        echo "IMAGE_NAME=${GITHUB_REPOSITORY,,}" >> $GITHUB_ENV

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=semver,pattern={{major}}
          type=sha,prefix=sha-

    - name: Build and push API image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./ops/docker/api/Dockerfile
        push: true
        tags: |
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/api:latest
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/api:${{ steps.meta.outputs.version }}
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/api:sha-${{ github.sha }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha,scope=api-build
        cache-to: type=gha,mode=max,scope=api-build
        # OPTIMIZATION: Single platform only (was linux/amd64,linux/arm64)
        platforms: linux/amd64
        provenance: false

    - name: Build and push MLflow image
      id: build-mlflow
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ops/docker/mlflow/Dockerfile
        push: true
        tags: |
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/mlflow:latest
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/mlflow:${{ steps.meta.outputs.version }}
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/mlflow:sha-${{ github.sha }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha,scope=mlflow-build
        cache-to: type=gha,mode=max,scope=mlflow-build
        platforms: linux/amd64
        provenance: false

    - name: Generate SBOM (API)
      uses: anchore/sbom-action@v0
      with:
        # OCI references must be lowercase
        image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/api@${{ steps.build.outputs.digest }}
        format: spdx-json
        output-file: sbom-api.spdx.json

    - name: Generate SBOM (MLflow)
      uses: anchore/sbom-action@v0
      with:
        # OCI references must be lowercase
        image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/mlflow@${{ steps.build-mlflow.outputs.digest }}
        format: spdx-json
        output-file: sbom-mlflow.spdx.json

    - name: Upload SBOM
      uses: actions/upload-artifact@v4
      with:
        name: sbom
        path: |
          sbom-api.spdx.json
          sbom-mlflow.spdx.json

  # ==========================================================================
  # DEPLOY TO DEMO INSTANCE - Only when ENABLE_DEMO_DEPLOY is true
  # ==========================================================================
  deploy-demo:
    name: Deploy to Demo Instance
    runs-on: ubuntu-latest
    needs: [build-and-push, terraform-apply]
    if: |
      always() &&
      needs.build-and-push.result == 'success' &&
      (needs.terraform-apply.result == 'success' || needs.terraform-apply.result == 'skipped') &&
      github.ref == 'refs/heads/main' &&
      vars.ENABLE_DEMO_DEPLOY == 'true'

    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-east-1

    - name: Get EC2 instance IP
      id: ec2
      run: |
        INSTANCE_IP=$(aws ec2 describe-instances \
          --filters "Name=tag:Name,Values=rt-ml-platform-demo-instance" \
                    "Name=instance-state-name,Values=running" \
          --query "Reservations[*].Instances[*].PublicIpAddress" \
          --output text)
        if [ -z "$INSTANCE_IP" ]; then
          echo "::error::No running demo instance found"
          exit 1
        fi
        echo "ip=$INSTANCE_IP" >> $GITHUB_OUTPUT
        echo "Found demo instance at $INSTANCE_IP"

    - name: Deploy new images (zero-downtime)
      uses: appleboy/ssh-action@v1
      with:
        host: ${{ steps.ec2.outputs.ip }}
        username: ubuntu
        key: ${{ secrets.EC2_SSH_KEY }}
        script: |
          IMAGE_TAG="sha-${{ github.sha }}"
          REGISTRY="ghcr.io/italopinheiro/rt-ml-multicloud-platform"

          echo "ðŸš€ Deploying images with tag: ${IMAGE_TAG}"

          # Update image tags â€” K3s pulls from GHCR via imagePullSecret
          sudo k3s kubectl set image deployment/ml-pipeline-api \
            api=${REGISTRY}/api:${IMAGE_TAG} -n ml-pipeline
          sudo k3s kubectl set image deployment/mlflow \
            mlflow=${REGISTRY}/mlflow:${IMAGE_TAG} -n ml-pipeline

          # Wait for rollout (zero-downtime: new pod Ready â†’ old pod terminated)
          echo "â³ Waiting for API rollout..."
          sudo k3s kubectl rollout status deployment/ml-pipeline-api \
            -n ml-pipeline --timeout=300s
          echo "â³ Waiting for MLflow rollout..."
          sudo k3s kubectl rollout status deployment/mlflow \
            -n ml-pipeline --timeout=300s

          echo "âœ… Deployment complete"

    - name: Verify deployment
      uses: appleboy/ssh-action@v1
      with:
        host: ${{ steps.ec2.outputs.ip }}
        username: ubuntu
        key: ${{ secrets.EC2_SSH_KEY }}
        script: |
          echo "=== Pod Status ==="
          sudo k3s kubectl get pods -n ml-pipeline
          echo ""
          echo "=== API Health Check ==="
          curl -sf http://localhost:30800/health || echo "âš ï¸ API not healthy yet (may still be starting)"

  # ==========================================================================
  # VALIDATE STAGING - Always runs (no cluster needed)
  # ==========================================================================
  validate-staging:
    name: Validate Staging Manifests
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.ref == 'refs/heads/main'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Kustomize
      uses: imranismail/setup-kustomize@v2

    - name: Validate staging manifests
      run: |
        kustomize build ops/k8s/overlays/staging > /tmp/staging-manifests.yaml
        echo "âœ… Staging manifests validated successfully"
        echo "ðŸ“¦ Manifest size: $(wc -l < /tmp/staging-manifests.yaml) lines"
        
    - name: Update image tag for validation
      run: |
        cd ops/k8s/overlays/staging
        kustomize edit set image ml-pipeline/api=ghcr.io/italopinheiro/rt-ml-multicloud-platform:main
        echo "âœ… Image tag updated"

    - name: Show rendered manifests (preview)
      run: |
        echo "=== Staging Manifests Preview ==="
        kustomize build ops/k8s/overlays/staging | head -100
        echo "... (truncated)"

  # ==========================================================================
  # DEPLOY TO STAGING - Only when ENABLE_STAGING_DEPLOY is true
  # ==========================================================================
  deploy-staging:
    name: Deploy to Staging Cluster
    runs-on: ubuntu-latest
    needs: validate-staging
    environment: staging
    if: |
      github.ref == 'refs/heads/main' && 
      (vars.ENABLE_STAGING_DEPLOY == 'true' || github.event.inputs.deploy_staging == 'true')

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Configure kubectl for staging
      run: |
        mkdir -p ~/.kube
        echo "${{ secrets.KUBECONFIG_STAGING }}" | base64 -d > ~/.kube/config

    - name: Update image tag in manifests
      run: |
        cd ops/k8s/overlays/staging
        kustomize edit set image ml-pipeline/api=ghcr.io/italopinheiro/rt-ml-multicloud-platform:${{ github.sha }}

    - name: Deploy to staging
      run: |
        kubectl apply -k ops/k8s/overlays/staging/
        kubectl rollout status deployment/ml-pipeline-api -n ml-pipeline-staging --timeout=300s

    - name: Run smoke tests
      run: |
        kubectl wait --for=condition=available --timeout=300s deployment/ml-pipeline-api -n ml-pipeline-staging
        STAGING_URL=$(kubectl get service ml-pipeline-api-service -n ml-pipeline-staging -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        curl -f "http://${STAGING_URL}:8000/health" || exit 1

  # ==========================================================================
  # DEPLOY TO PRODUCTION - Only when ENABLE_PRODUCTION_DEPLOY is true
  # ==========================================================================
  deploy-production:
    name: Deploy to Production Cluster
    runs-on: ubuntu-latest
    needs: deploy-staging
    environment: production
    if: |
      github.ref == 'refs/heads/main' && 
      (vars.ENABLE_PRODUCTION_DEPLOY == 'true' || github.event.inputs.deploy_production == 'true')

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Configure kubectl for production
      run: |
        mkdir -p ~/.kube
        echo "${{ secrets.KUBECONFIG_PRODUCTION }}" | base64 -d > ~/.kube/config
        
  # ==========================================================================
  # CLEANUP - Always runs
  # ==========================================================================
  cleanup:
    name: Cleanup Old Images
    runs-on: ubuntu-latest
    needs: [validate-staging]
    if: always() && needs.validate-staging.result == 'success'
    permissions:
      packages: write

    steps:
    - name: Clean up old images
      run: |
        echo "ðŸ§¹ Cleaning up old untagged images..."
        # Note: In GHCR, packages pushed to user/repo/image become namespaced packages.
        # We must URL encode the slash as %2f for the API path.
        
        PACKAGES=("rt-ml-multicloud-platform%2fapi" "rt-ml-multicloud-platform%2fmlflow")

        for PKG in "${PACKAGES[@]}"; do
          echo "Processing package: $PKG"
          
          # Use the USER endpoint since these are user-owned packages
          gh api "users/${{ github.repository_owner }}/packages/container/${PKG}/versions" \
            --jq '.[] | select(.metadata.container.tags | length == 0) | .id' \
            | tail -n +6 \
            | xargs -I {} gh api --method DELETE "users/${{ github.repository_owner }}/packages/container/${PKG}/versions/{}" || true
        done
        echo "âœ… Cleanup complete"
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      continue-on-error: true

  # ==========================================================================
  # TERRAFORM PLAN - Runs on changes to ops/terraform
  # ==========================================================================
  terraform-plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    if: |
      github.event_name == 'pull_request' ||
      github.ref == 'refs/heads/main'

    defaults:
      run:
        working-directory: ops/terraform/aws/demo

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: "1.7.0"

    - name: Terraform Init
      id: init
      run: terraform init -backend=false

    - name: Terraform Validate
      id: validate
      run: terraform validate -no-color


    - name: Terraform Plan
      id: plan
      run: terraform plan -no-color -var="key_name=dummy-key"
      continue-on-error: true
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_REGION: us-east-1


  # ==========================================================================
  # TERRAFORM APPLY - Runs only on main branch after successful plan
  # ==========================================================================
  terraform-apply:
    name: Terraform Apply
    runs-on: ubuntu-latest
    needs: terraform-plan
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: production # Use environment for protection rules (manual approval)

    defaults:
      run:
        working-directory: ops/terraform/aws/demo

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: "1.7.0"

    - name: Terraform Init
      run: terraform init -backend=true
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_REGION: us-east-1

    - name: Terraform Apply
      run: terraform apply -auto-approve -var="key_name=${{ secrets.AWS_KEY_NAME }}"
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_REGION: us-east-1

  # ==========================================================================
  # SUMMARY - Shows what ran and what was skipped
  # ==========================================================================
  summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-demo, validate-staging, deploy-staging, deploy-production, cleanup, terraform-plan, terraform-apply]
    if: always()

    steps:
    - name: Generate summary
      run: |
        echo "## ðŸ“Š Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "| Stage | Status |" >> $GITHUB_STEP_SUMMARY
        echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
        echo "| Build & Push | ${{ needs.build-and-push.result }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Deploy Demo | ${{ needs.deploy-demo.result || 'skipped (ENABLE_DEMO_DEPLOY=false)' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Terraform Plan | ${{ needs.terraform-plan.result }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Terraform Apply | ${{ needs.terraform-apply.result || 'skipped (not main branch)' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Validate Staging | ${{ needs.validate-staging.result }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Deploy Staging | ${{ needs.deploy-staging.result || 'skipped (ENABLE_STAGING_DEPLOY=false)' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Deploy Production | ${{ needs.deploy-production.result || 'skipped (ENABLE_PRODUCTION_DEPLOY=false)' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Cleanup | ${{ needs.cleanup.result }} |" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ”§ Feature Flags" >> $GITHUB_STEP_SUMMARY
        echo "- \`ENABLE_DEMO_DEPLOY\`: Set in repo variables to enable demo instance deployment" >> $GITHUB_STEP_SUMMARY
        echo "- \`ENABLE_STAGING_DEPLOY\`: Set in repo variables to enable staging deployment" >> $GITHUB_STEP_SUMMARY
        echo "- \`ENABLE_PRODUCTION_DEPLOY\`: Set in repo variables to enable production deployment" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "To enable deployments, go to **Settings > Secrets and variables > Actions > Variables**" >> $GITHUB_STEP_SUMMARY