name: Continuous Deployment

on:
  push:
    branches: [ main ]
    tags: [ 'v*' ]
  workflow_dispatch:
    inputs:
      deploy_staging:
        description: 'Deploy to staging cluster'
        required: false
        type: boolean
        default: false
      deploy_production:
        description: 'Deploy to production cluster'
        required: false
        type: boolean
        default: false

env:
  REGISTRY: ghcr.io
  PYTHON_VERSION: '3.11'
  
  # ============================================================================
  # DEPLOYMENT FEATURE FLAGS
  # Set to 'true' when infrastructure is ready
  # ============================================================================
  ENABLE_STAGING_DEPLOY: 'false'      # Set to 'true' when staging K8s is ready
  ENABLE_PRODUCTION_DEPLOY: 'false'   # Set to 'true' when production K8s is ready
  ENABLE_SLACK_NOTIFICATIONS: 'false' # Set to 'true' when Slack webhook is configured

jobs:
  # ==========================================================================
  # BUILD AND PUSH - Always runs
  # ==========================================================================
  build-and-push:
    name: Build & Push Docker Images
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-tag: ${{ steps.meta.outputs.tags }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Image Name (Lowercase)
      run: |
        echo "IMAGE_NAME=${GITHUB_REPOSITORY,,}" >> $GITHUB_ENV

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=semver,pattern={{major}}
          type=sha,prefix=sha-

    - name: Build and push API image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./ops/docker/api/Dockerfile
        push: true
        tags: |
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/api:latest
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/api:${{ steps.meta.outputs.version }}
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/api:sha-${{ github.sha }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        # OPTIMIZATION: Single platform only (was linux/amd64,linux/arm64)
        platforms: linux/amd64

    - name: Build and push MLflow image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ops/docker/mlflow/Dockerfile
        push: true
        tags: |
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/mlflow:latest
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/mlflow:${{ steps.meta.outputs.version }}
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/mlflow:sha-${{ github.sha }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64

    - name: Generate SBOM
      uses: anchore/sbom-action@v0
      with:
        # OCI references must be lowercase
        image: ghcr.io/italopinheiro/rt-ml-multicloud-platform@${{ steps.build.outputs.digest }}
        format: spdx-json
        output-file: sbom.spdx.json

    - name: Upload SBOM
      uses: actions/upload-artifact@v4
      with:
        name: sbom
        path: sbom.spdx.json

  # ==========================================================================
  # VALIDATE STAGING - Always runs (no cluster needed)
  # ==========================================================================
  validate-staging:
    name: Validate Staging Manifests
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.ref == 'refs/heads/main'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Kustomize
      uses: imranismail/setup-kustomize@v2

    - name: Validate staging manifests
      run: |
        kustomize build ops/k8s/overlays/staging > /tmp/staging-manifests.yaml
        echo "âœ… Staging manifests validated successfully"
        echo "ðŸ“¦ Manifest size: $(wc -l < /tmp/staging-manifests.yaml) lines"
        
    - name: Update image tag for validation
      run: |
        cd ops/k8s/overlays/staging
        kustomize edit set image ml-pipeline/api=ghcr.io/italopinheiro/rt-ml-multicloud-platform:main
        echo "âœ… Image tag updated"

    - name: Show rendered manifests (preview)
      run: |
        echo "=== Staging Manifests Preview ==="
        kustomize build ops/k8s/overlays/staging | head -100
        echo "... (truncated)"

  # ==========================================================================
  # DEPLOY TO STAGING - Only when ENABLE_STAGING_DEPLOY is true
  # ==========================================================================
  deploy-staging:
    name: Deploy to Staging Cluster
    runs-on: ubuntu-latest
    needs: validate-staging
    environment: staging
    if: |
      github.ref == 'refs/heads/main' && 
      (vars.ENABLE_STAGING_DEPLOY == 'true' || github.event.inputs.deploy_staging == 'true')

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Configure kubectl for staging
      run: |
        mkdir -p ~/.kube
        echo "${{ secrets.KUBECONFIG_STAGING }}" | base64 -d > ~/.kube/config

    - name: Update image tag in manifests
      run: |
        cd ops/k8s/overlays/staging
        kustomize edit set image ml-pipeline/api=ghcr.io/italopinheiro/rt-ml-multicloud-platform:${{ github.sha }}

    - name: Deploy to staging
      run: |
        kubectl apply -k ops/k8s/overlays/staging/
        kubectl rollout status deployment/ml-pipeline-api -n ml-pipeline-staging --timeout=300s

    - name: Run smoke tests
      run: |
        kubectl wait --for=condition=available --timeout=300s deployment/ml-pipeline-api -n ml-pipeline-staging
        STAGING_URL=$(kubectl get service ml-pipeline-api-service -n ml-pipeline-staging -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        curl -f "http://${STAGING_URL}:8000/health" || exit 1

  # ==========================================================================
  # DEPLOY TO PRODUCTION - Only when ENABLE_PRODUCTION_DEPLOY is true
  # ==========================================================================
  deploy-production:
    name: Deploy to Production Cluster
    runs-on: ubuntu-latest
    needs: deploy-staging
    environment: production
    if: |
      github.ref == 'refs/heads/main' && 
      (vars.ENABLE_PRODUCTION_DEPLOY == 'true' || github.event.inputs.deploy_production == 'true')

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Configure kubectl for production
      run: |
        mkdir -p ~/.kube
        echo "${{ secrets.KUBECONFIG_PRODUCTION }}" | base64 -d > ~/.kube/config

    - name: Deploy to production
      run: |
        kubectl apply -k ops/k8s/overlays/production/
        kubectl rollout status deployment/ml-pipeline-api -n ml-pipeline-prod --timeout=300s

  # ==========================================================================
  # CLEANUP - Always runs
  # ==========================================================================
  cleanup:
    name: Cleanup Old Images
    runs-on: ubuntu-latest
    needs: [validate-staging]
    if: always() && needs.validate-staging.result == 'success'

    steps:
    - name: Clean up old images
      run: |
        echo "ðŸ§¹ Cleaning up old untagged images..."
        gh api repos/${{ github.repository }}/packages/container/${{ github.event.repository.name }}/versions \
          --jq '.[] | select(.metadata.container.tags | length == 0) | .id' \
          | tail -n +11 \
          | xargs -I {} gh api --method DELETE repos/${{ github.repository }}/packages/container/${{ github.event.repository.name }}/versions/{} || true
        echo "âœ… Cleanup complete"
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      continue-on-error: true


  # ==========================================================================
  # TERRAFORM PLAN - Runs on changes to ops/terraform
  # ==========================================================================
  terraform-plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    if: |
      github.event_name == 'pull_request' ||
      github.ref == 'refs/heads/main'

    defaults:
      run:
        working-directory: ops/terraform/aws/demo

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: "1.7.0"

    - name: Terraform Init
      id: init
      run: terraform init -backend=false

    - name: Terraform Validate
      id: validate
      run: terraform validate -no-color


    - name: Terraform Plan
      id: plan
      run: terraform plan -no-color -var="key_name=dummy-key"
      continue-on-error: true
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_REGION: us-east-1


  # ==========================================================================
  # TERRAFORM APPLY - Runs only on main branch after successful plan
  # ==========================================================================
  terraform-apply:
    name: Terraform Apply
    runs-on: ubuntu-latest
    needs: terraform-plan
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: production # Use environment for protection rules (manual approval)

    defaults:
      run:
        working-directory: ops/terraform/aws/demo

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: "1.7.0"

    - name: Terraform Init
      run: terraform init -backend=true

    - name: Terraform Apply
      run: terraform apply -auto-approve -var="key_name=${{ secrets.AWS_KEY_NAME }}"
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_REGION: us-east-1

  # ==========================================================================
  # SUMMARY - Shows what ran and what was skipped
  # ==========================================================================
  summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [build-and-push, validate-staging, deploy-staging, deploy-production, cleanup, terraform-plan, terraform-apply]
    if: always()

    steps:
    - name: Generate summary
      run: |
        echo "## ðŸ“Š Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "| Stage | Status |" >> $GITHUB_STEP_SUMMARY
        echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
        echo "| Build & Push | ${{ needs.build-and-push.result }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Terraform Plan | ${{ needs.terraform-plan.result }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Terraform Apply | ${{ needs.terraform-apply.result || 'skipped (not main branch)' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Validate Staging | ${{ needs.validate-staging.result }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Deploy Staging | ${{ needs.deploy-staging.result || 'skipped (ENABLE_STAGING_DEPLOY=false)' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Deploy Production | ${{ needs.deploy-production.result || 'skipped (ENABLE_PRODUCTION_DEPLOY=false)' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Cleanup | ${{ needs.cleanup.result }} |" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ”§ Feature Flags" >> $GITHUB_STEP_SUMMARY
        echo "- \`ENABLE_STAGING_DEPLOY\`: Set in repo variables to enable staging deployment" >> $GITHUB_STEP_SUMMARY
        echo "- \`ENABLE_PRODUCTION_DEPLOY\`: Set in repo variables to enable production deployment" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "To enable deployments, go to **Settings > Secrets and variables > Actions > Variables**" >> $GITHUB_STEP_SUMMARY